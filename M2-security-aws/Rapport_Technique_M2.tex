\documentclass[a4paper,12pt]{article}

% Packages pour l'encodage et la langue
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{lipsum} % Pour le remplissage si nécessaire (non utilisé ici, tout est réel)

% Mise en page
\usepackage[margin=2.5cm]{geometry}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{titlesec}
\usepackage{float}
\usepackage{setspace} % Pour l'interligne

% Graphiques et Couleurs
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,shadows,calc}

% Liens et Code
\usepackage{hyperref}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{longtable}

% Configuration des couleurs
\definecolor{primary}{RGB}{0, 51, 102} % Bleu foncé professionnel
\definecolor{secondary}{RGB}{204, 0, 0} % Rouge (FanOps)
\definecolor{accent}{RGB}{0, 153, 76}   % Vert (Succès/Validé)
\definecolor{codegray}{rgb}{0.95,0.95,0.95}
\definecolor{codeblue}{rgb}{0.0,0.0,0.6}
\definecolor{yamlkey}{rgb}{0.0,0.5,0.0}

% Configuration des listings de code
\lstset{
    backgroundcolor=\color{codegray},
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    captionpos=b,
    frame=single,
    keywordstyle=\color{codeblue}\bfseries,
    commentstyle=\color{green!50!black},
    stringstyle=\color{secondary},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    tabsize=2,
    showstringspaces=false,
    inputencoding=utf8,
    extendedchars=true,
    literate={é}{{\'e}}1 {è}{{\`e}}1 {à}{{\`a}}1 {ç}{{\c{c}}}1 {œ}{{\oe}}1 {ù}{{\`u}}1 {É}{{\'E}}1 {È}{{\`E}}1 {À}{{\`A}}1 {Ç}{{\c{C}}}1 {Œ}{{\OE}}1 {Ê}{{\^E}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
}

\lstdefinelanguage{yaml}{
  keywords={true,false,null,y,n},
  keywordstyle=\color{darkgray}\bfseries,
  basicstyle=\ttfamily\footnotesize,
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{blue}\ttfamily,
  moredelim=[l][\color{orange}]{\&},
  moredelim=[l][\color{magenta}]{*},
  moredelim=**[il][\color{secondary}{: }],
  morestring=[b]',
  morestring=[b]"
}

% Espacement des paragraphes
\setlength{\parskip}{0.8em}
\setlength{\parindent}{0pt}
\onehalfspacing

% En-têtes et pieds de page
\pagestyle{fancy}
\fancyhf{}
\lhead{\textbf{Projet FanOps - CAN 2025}}
\rhead{Module M2 : Secure Gates}
\rfoot{Page \thepage \hspace{1pt} sur \pageref{LastPage}}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}

% Titre du document
\title{
    \vspace{-2cm}
    \begin{tcolorbox}[colback=primary,colframe=primary,arc=0pt,boxrule=0pt, width=\textwidth]
        \centering \textcolor{white}{\Huge \textbf{Rapport Technique Détaillé}} \\
        \vspace{0.5cm}
        \textcolor{white}{\Large \textbf{Service de Sécurité M2 (Secure Gates)}}
    \end{tcolorbox}
    \vspace{2cm}
    \begin{center}
        \includegraphics[width=0.3\textwidth]{example-image-a} % Placeholder logo
    \end{center}
    \vspace{1cm}
    \begin{center}
        \Huge \textbf{Architecture Cloud Hybride, Sécurité Offensive \& DevSecOps}
    \end{center}
    \vspace{2cm}
    \large
    \textbf{Contexte :} Coupe d'Afrique des Nations 2025 \\
    \textbf{Domaine :} Cloud Computing, Serverless, SIEM, Cybersécurité
}
\author{\textbf{Équipe Technique FanOps}}
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

\listoffigures
\listoftables
\newpage

% ---------------------------------------------------------------------------
\section{1. Introduction et Contexte Stratégique}

\subsection{1.1 Le Défi de la CAN 2025}
L'organisation de la \textbf{Coupe d'Afrique des Nations (CAN) 2025} au Maroc est un événement d'envergure internationale qui drainera des millions de spectateurs. Au-delà de l'aspect sportif, c'est un défi technologique et sécuritaire majeur.

La gestion des accès aux stades est critique. Une défaillance du système de billetterie peut entraîner :
\begin{itemize}
    \item Des émeutes aux portes des stades (problème de sécurité publique).
    \item Une perte financière massive due à la fraude (faux billets, réutilisation).
    \item Une atteinte à la réputation de l'organisation.
\end{itemize}

\subsection{1.2 Objectifs du Module M2 (Secure Gates)}
Le module \textbf{M2 - Secure Gates} a été conçu pour répondre à ces risques avec une approche "Zero Trust". Ses objectifs principaux sont :

\begin{enumerate}
    \item \textbf{Authenticité Cryptographique} : Garantir qu'aucun billet ne peut être falsifié.
    \item \textbf{Unicité (Anti-Replay)} : Empêcher qu'un billet valide (copié ou volé) soit utilisé plus d'une fois.
    \item \textbf{Haute Disponibilité} : Supporter des pics de charge extrêmes (100 000 scans en 15 minutes avant le coup d'envoi).
    \item \textbf{Observabilité Totale} : Fournir une vue en temps réel des menaces et des accès au SOC (Security Operations Center).
\end{enumerate}

\subsection{1.3 Périmètre Technique}
Ce rapport couvre l'intégralité de la chaîne de valeur technique :
\begin{itemize}
    \item L'infrastructure Cloud sur \textbf{AWS} (Amazon Web Services).
    \item La couche de sécurité et de surveillance sur \textbf{Microsoft Azure}.
    \item L'automatisation des tests de sécurité (DevSecOps).
    \item L'analyse financière (FinOps).
\end{itemize}

\newpage

% ---------------------------------------------------------------------------
\section{2. Architecture Cloud Hybride}

Nous avons fait le choix audacieux d'une architecture \textbf{Hybride Multi-Cloud}, tirant parti du meilleur de chaque fournisseur ("Best of Breed").

\subsection{2.1 Vue d'Ensemble de l'Architecture}

L'architecture est divisée en trois zones distinctes :
\begin{enumerate}
    \item \textbf{La Zone Compute (AWS)} : Héberge la logique métier et les données.
    \item \textbf{La Zone Sécurité (Azure)} : Centralise la surveillance et la détection des menaces.
    \item \textbf{La Zone Client (Edge)} : Les terminaux mobiles des agents de sécurité.
\end{enumerate}

\begin{figure}[H]
\centering
\begin{tikzpicture}[node distance=1.5cm, auto, >=stealth]
    % Styles
    \tikzstyle{service} = [rectangle, draw=primary, fill=blue!5, text width=3cm, text centered, rounded corners, minimum height=1.5cm]
    \tikzstyle{db} = [cylinder, draw=primary, fill=orange!10, shape border rotate=90, aspect=0.25, text width=2.5cm, text centered, minimum height=1.5cm]
    
    % Nodes
    \node[service, fill=green!10] (client) {Frontend React (Vite)};
    \node[service, below=of client, yshift=-1cm] (api) {AWS API Gateway};
    \node[service, below=of api] (lambda) {AWS Lambda (Node.js)};
    
    \node[db, below left=of lambda, xshift=-2cm] (dynamo) {DynamoDB};
    \node[service, below right=of lambda, xshift=2cm] (kms) {AWS KMS};
    
    \node[service, right=of api, xshift=4cm, fill=blue!10] (sentinel) {Azure Sentinel};
    \node[service, below=of sentinel] (ec2) {EC2 (ZAP Scanner)};

    % Edges
    \draw[->, thick] (client) -- node[right] {HTTPS/REST} (api);
    \draw[->, thick] (api) -- (lambda);
    \draw[->, thick] (lambda) -- (dynamo);
    \draw[->, thick] (lambda) -- (kms);
    \draw[->, thick, dashed, color=red] (ec2) -- node[above] {Attaques} (api);
    \draw[->, thick, dashed, color=blue] (lambda) -- node[above] {Logs} (sentinel);
    \draw[->, thick, dashed, color=blue] (ec2) -- node[right] {Rapports S3} (sentinel);
\end{tikzpicture}
\caption{Diagramme d'Architecture Hybride AWS/Azure}
\end{figure}

\subsection{2.2 Pourquoi le Serverless ?}
Le choix du Serverless (AWS Lambda + DynamoDB) est justifié par trois facteurs :
\begin{itemize}
    \item \textbf{Scalabilité} : Contrairement à des serveurs EC2 classiques, Lambda peut passer de 0 à 10 000 exécutions concurrentes en quelques secondes. C'est idéal pour un stade qui se remplit massivement en peu de temps.
    \item \textbf{Coût} : Nous ne payons que pour le temps d'exécution (à la milliseconde). Les jours sans match, le coût est de 0\$.
    \item \textbf{Maintenance} : Pas d'OS à patcher, pas de serveurs à gérer. L'équipe se concentre sur le code.
\end{itemize}

\newpage

% ---------------------------------------------------------------------------
\section{3. Composants AWS : Le Moteur Backend}

Cette section détaille la configuration technique des services AWS.

\subsection{3.1 Amazon API Gateway (Front Door)}
L'API Gateway a été déployée comme point d'entrée RESTful pour exposer nos fonctions Lambda de manière sécurisée et standardisée.

\subsubsection{Architecture des Ressources Déployées}
Conformément à la configuration \texttt{serverless.yml}, nous avons déployé les endpoints suivants sur le stage \textbf{dev} :

\begin{itemize}
    \item \textbf{Groupe /auth} :
    \begin{itemize}
        \item \texttt{POST /auth/login} : Connecté à la Lambda \texttt{login}. Permet l'authentification des agents et retourne le JWT.
        \item \texttt{POST /auth/logout} : Connecté à la Lambda \texttt{logout}. Gère la fin de session.
    \end{itemize}
    \item \textbf{Groupe /security} :
    \begin{itemize}
        \item \texttt{POST /security/verifyTicket} : Connecté à \texttt{verifyTicket}. Reçoit le token du QR Code et retourne le statut d'accès.
        \item \texttt{POST /security/reportGate} : Connecté à \texttt{reportGate}. Collecte les données de télémétrie.
        \item \texttt{GET /security/metrics} : Connecté à \texttt{getSecurityMetrics}. Expose les KPIs pour le dashboard.
    \end{itemize}
\end{itemize}

\subsubsection{Configuration Technique}
\begin{enumerate}
    \item \textbf{Intégration Lambda Proxy} : Nous utilisons l'intégration "AWS\_PROXY". Cela signifie que l'API Gateway transmet la requête HTTP brute (Headers, Body, Query Params) directement à la fonction Lambda sous forme d'événement JSON. La Lambda est responsable de former la réponse HTTP complète (StatusCode, Body).
    \item \textbf{CORS (Cross-Origin Resource Sharing)} : Le flag \texttt{cors: true} a été activé sur toutes les routes. Cela configure automatiquement les headers \texttt{Access-Control-Allow-Origin: *} pour permettre au Frontend React (hébergé localement ou sur un autre domaine) d'appeler l'API sans blocage par le navigateur.
    \item \textbf{Stage de Déploiement} : L'API est actuellement déployée sur le stage \texttt{dev}, générant une URL de base du type \texttt{https://xyz.execute-api.eu-west-1.amazonaws.com/dev}.
\end{enumerate}

\subsection{3.2 AWS Lambda (Compute)}
Nous utilisons le runtime \textbf{Node.js 20.x}. Le code est découpé en micro-fonctions pour respecter le principe de responsabilité unique.

\subsubsection{Fonction \texttt{verifyTicket}}
C'est la fonction la plus critique. Elle exécute la logique suivante :
\begin{enumerate}
    \item Réception du JWT.
    \item Déchiffrement de la clé secrète via KMS.
    \item Vérification de la signature du JWT.
    \item Vérification de l'existence du billet dans la table \texttt{SoldTickets}.
    \item Vérification de l'unicité dans la table \texttt{UsedJTI}.
    \item Enregistrement de l'utilisation.
\end{enumerate}

\begin{lstlisting}[language=Javascript, caption=Logique de vérification (extrait)]
// Verification de la signature
try {
    const decoded = jwt.verify(token, secret);
} catch (err) {
    throw new Error('INVALID_SIGNATURE');
}

// Verification Anti-Replay
const used = await dynamo.get({ TableName: 'UsedJTI', Key: { jti: decoded.jti } });
if (used.Item) {
    throw new Error('REPLAY_ATTACK');
}
\end{lstlisting}

\subsubsection{Fonction \texttt{login} (Authentification)}
Cette fonction gère l'accès des agents de sécurité (Gatekeepers) à l'application.
\begin{enumerate}
    \item Réception des identifiants (username, password).
    \item Recherche de l'utilisateur dans la table \texttt{Users}.
    \item Comparaison du mot de passe haché avec \texttt{bcrypt}.
    \item Génération d'un token JWT signé avec la clé KMS.
\end{enumerate}

\begin{lstlisting}[language=Javascript, caption=Logique d'authentification]
// Validation du mot de passe
const isValid = await bcrypt.compare(password, user.passwordHash);
if (!isValid) throw new Error('INVALID_CREDENTIALS');

// Generation du JWT
const token = jwt.sign({ 
    sub: user.userId, 
    role: user.role 
}, secret, { expiresIn: '8h' });
\end{lstlisting}

\subsubsection{Fonction \texttt{sentinelShipper} (Log Forwarder)}
Cette fonction assure le pont entre AWS et Azure. Elle est déclenchée asynchronement par les logs CloudWatch.
\begin{enumerate}
    \item Décompression des logs (Gzip).
    \item Filtrage des messages pertinents (Erreurs, Audits).
    \item Envoi vers l'API HTTP Data Collector d'Azure Monitor.
\end{enumerate}

\begin{lstlisting}[language=Javascript, caption=Transfert de logs vers Azure]
// Envoi a Azure Sentinel
await axios.post(azureUrl, logs, {
    headers: {
        'Log-Type': 'AppEvents',
        'Authorization': signature,
        'x-ms-date': date
    }
});
\end{lstlisting}

\subsubsection{Fonction \texttt{reportGate} (Monitoring)}
Permet aux portiques de remonter leur état de santé (Batterie, Connectivité, Erreurs matérielles).
\begin{enumerate}
    \item Réception de l'état du portique.
    \item Enregistrement dans la table \texttt{Audit}.
    \item Si l'état est critique, déclenchement d'une alerte via SNS (Simple Notification Service).
\end{enumerate}

\begin{lstlisting}[language=Javascript, caption=Rapport d'état des portiques]
// Enregistrement de l'etat
await dynamo.put({
    TableName: 'Audit',
    Item: {
        auditId: uuidv4(),
        type: 'GATE_STATUS',
        gateId: event.gateId,
        status: event.status, // ex: "ERROR_SENSOR"
        timestamp: new Date().toISOString()
    }
});
\end{lstlisting}

\subsubsection{Fonction \texttt{logAnalyzer} (Sécurité Temps Réel)}
Cette fonction est déclenchée par les \textbf{DynamoDB Streams} de la table Audit. Elle analyse les événements au fil de l'eau pour une réaction immédiate.
\begin{enumerate}
    \item Réception d'un lot d'enregistrements (Stream Records).
    \item Détection de motifs suspects (ex: 5 échecs consécutifs sur le même portique).
    \item Déclenchement d'actions correctives (ex: Désactivation temporaire du portique).
\end{enumerate}

\begin{lstlisting}[language=Javascript, caption=Analyse de flux DynamoDB]
// Traitement des records
for (const record of event.Records) {
    if (record.eventName === 'INSERT') {
        const auditLog = AWS.DynamoDB.Converter.unmarshall(record.dynamodb.NewImage);
        if (auditLog.type === 'REPLAY_ATTACK') {
            await alertAdmin(auditLog);
        }
    }
}
\end{lstlisting}

\subsubsection{Fonction \texttt{getSecurityMetrics} (Dashboard)}
Alimente le tableau de bord de sécurité en fournissant des statistiques agrégées en temps réel.
\begin{enumerate}
    \item Scan optimisé de la table \texttt{Audit} (ou interrogation d'une table d'agrégation).
    \item Calcul des KPIs : Nombre de billets scannés, Taux de refus, Portiques actifs.
    \item Renvoi des données au Frontend Admin.
\end{enumerate}

\begin{lstlisting}[language=Javascript, caption=Récupération des métriques]
// Calcul des stats
const stats = {
    totalScans: await countEvents('SCAN_SUCCESS'),
    fraudAttempts: await countEvents('REPLAY_ATTACK'),
    activeGates: await getActiveGatesCount()
};
return { statusCode: 200, body: JSON.stringify(stats) };
\end{lstlisting}

\subsubsection{Fonction \texttt{logout} (Session)}
Gère la déconnexion sécurisée des agents. Bien que les JWT soient stateless, cette fonction permet d'auditer la fin de session.
\begin{enumerate}
    \item Réception de la demande de déconnexion.
    \item Enregistrement de l'événement "LOGOUT" dans la table d'audit.
    \item (Optionnel) Ajout du JTI du token utilisateur dans une liste de révocation (Blacklist) temporaire.
\end{enumerate}

\begin{lstlisting}[language=Javascript, caption=Déconnexion]
// Audit de la deconnexion
await logAudit({
    type: 'USER_LOGOUT',
    userId: user.sub,
    timestamp: new Date().toISOString()
});
return { message: 'Logged out successfully' };
\end{lstlisting}

\subsubsection{Fonction \texttt{rotateKey} (Sécurité)}
Gère la rotation automatique des clés de signature JWT pour limiter l'impact en cas de compromission.
\begin{enumerate}
    \item Génération d'un nouveau secret aléatoire.
    \item Chiffrement avec KMS.
    \item Mise à jour du paramètre dans SSM Parameter Store.
    \item Invalidation des caches Lambda (via redéploiement ou signal).
\end{enumerate}

\begin{lstlisting}[language=Javascript, caption=Rotation des clés]
// Generation et chiffrement
const newSecret = crypto.randomBytes(32).toString('hex');
const encrypted = await kms.encrypt({ 
    KeyId: keyId, 
    Plaintext: newSecret 
}).promise();

// Mise a jour SSM
await ssm.putParameter({
    Name: '/can2025/dev/jwt-secret',
    Value: encrypted.CiphertextBlob.toString('base64'),
    Overwrite: true
}).promise();
\end{lstlisting}

\subsection{3.2 Amazon DynamoDB (Stockage)}
Nous utilisons le mode \textbf{On-Demand} pour gérer l'imprévisibilité du trafic.

\subsubsection{Modèle de Données Détaillé}
La conception NoSQL a été optimisée pour les accès par clé primaire (Key-Value Access Patterns), garantissant une latence constante quelle que soit la taille de la base.

\begin{longtable}{|p{3.5cm}|p{3.5cm}|p{8cm}|}
\hline
\textbf{Table} & \textbf{Structure (PK/SK)} & \textbf{Attributs & Usage} \\ \hline
\texttt{SoldTickets} & PK: \texttt{ticketId} (String) & 
\textbf{Attributs :} \texttt{matchId}, \texttt{seatNumber}, \texttt{type} (VIP/Standard), \texttt{jwt} (Hash de vérification), \texttt{status} (VALID/INVALID). \newline
\textbf{Usage :} Source de vérité lors du scan. Lecture ultra-rapide par ID. \\ \hline

\texttt{UsedJTI} & PK: \texttt{jti} (String) & 
\textbf{Attributs :} \texttt{ttl} (Number - Timestamp Unix). \newline
\textbf{Usage :} Table de verrouillage pour l'Anti-Replay. Si un JTI existe ici, le billet est rejeté. Le TTL purge automatiquement l'entrée après 24h pour réduire les coûts de stockage. \\ \hline

\texttt{Users} & PK: \texttt{userId} (String) & 
\textbf{Attributs :} \texttt{username}, \texttt{passwordHash} (Bcrypt), \texttt{role} (ADMIN/GATEKEEPER), \texttt{lastLogin}. \newline
\textbf{Usage :} Authentification des agents. \\ \hline

\texttt{Audit} & PK: \texttt{auditId} (UUID) & 
\textbf{Attributs :} \texttt{timestamp}, \texttt{type} (SCAN\_SUCCESS, REPLAY\_ATTACK), \texttt{gateId}, \texttt{details} (JSON). \newline
\textbf{Usage :} Traçabilité complète. Les Streams DynamoDB sont activés sur cette table pour alimenter \texttt{logAnalyzer}. \\ \hline
\caption{Schéma DynamoDB Optimisé}
\end{longtable}

\subsection{3.3 Architecture de Sécurité (KMS \& SSM)}
La gestion des secrets est le pilier de notre architecture "Zero Trust". Nous avons banni les secrets en clair (Hardcoded Secrets) au profit d'une gestion dynamique.

\subsubsection{Chiffrement des Données (Encryption at Rest)}
Toutes les tables DynamoDB sont chiffrées au repos (Server-Side Encryption) utilisant la clé gérée par AWS (\texttt{AWS/DynamoDB}). Cela garantit que le vol physique d'un disque dur dans un datacenter AWS ne compromettrait pas les données.

\subsubsection{Gestion des Clés de Signature (KMS + SSM)}
Le secret utilisé pour signer les JWT est protégé par une double barrière :
\begin{enumerate}
    \item \textbf{Stockage} : Le secret n'est pas dans le code, mais dans \textbf{AWS Systems Manager (SSM) Parameter Store} sous le chemin \texttt{/can2025/dev/jwt-secret}.
    \item \textbf{Chiffrement} : Ce paramètre est de type \texttt{SecureString}, chiffré avec une clé client (CMK) \textbf{AWS KMS} dédiée.
    \item \textbf{Accès IAM} : Seules les fonctions Lambda possédant le rôle IAM \texttt{kms:Decrypt} peuvent lire ce secret.
\end{enumerate}

\begin{figure}[H]
\centering
\begin{tikzpicture}[node distance=2cm, auto, >=stealth]
    \node[draw, rectangle] (lambda) {Lambda (Start)};
    \node[draw, rectangle, right of=lambda, xshift=3cm] (ssm) {SSM Parameter Store};
    \node[draw, rectangle, right of=ssm, xshift=3cm] (kms) {AWS KMS};
    
    \draw[->] (lambda) -- node[above] {1. GetParameter} (ssm);
    \draw[->] (ssm) -- node[above] {2. Return Encrypted Blob} (lambda);
    \draw[->] (lambda) to[bend left] node[above] {3. Decrypt(Blob)} (kms);
    \draw[->] (kms) to[bend left] node[below] {4. Return Plaintext Secret} (lambda);
\end{tikzpicture}
\caption{Flux de récupération sécurisée du secret JWT}
\end{figure}

Cette architecture permet la \textbf{Rotation des Clés} sans redéployer le code : il suffit de mettre à jour le paramètre SSM, et les Lambdas utiliseront le nouveau secret au prochain démarrage (Cold Start).

\newpage

% ---------------------------------------------------------------------------
\section{4. Sécurité Offensive et Audit Automatisé}

La sécurité n'est pas un état, c'est un processus. Pour garantir la robustesse du système, nous avons mis en place une chaîne d'audit continu.

\subsection{4.1 Le Concept de "Security as Code"}
Plutôt que d'attendre un audit annuel, nous auditons notre infrastructure tous les jours. Nous utilisons une instance EC2 dédiée qui agit comme un "Red Team" automatisé.

\subsection{4.2 Infrastructure de Scan (OWASP ZAP)}
\textbf{OWASP ZAP (Zed Attack Proxy)} est l'outil standard pour tester la sécurité des applications web.

\subsubsection{Configuration de l'Instance}
\begin{itemize}
    \item \textbf{OS} : Ubuntu 22.04 LTS.
    \item \textbf{Type} : t3.micro (suffisant pour des scans légers).
    \item \textbf{Réseau} : Security Group restreint (SSH uniquement depuis l'IP admin).
\end{itemize}

\subsubsection{Le Script d'Automatisation}
Un script Bash est exécuté via Cron chaque nuit à 02h00.

\begin{lstlisting}[language=bash, caption=Script daily\_scan.sh]
#!/bin/bash
DATE=$(date +%Y-%m-%d)
REPORT_NAME="zap-report-$DATE.html"
TARGET_URL="https://api.can2025.com/dev"
BUCKET_NAME="can2025-security-reports"

echo "Démarrage du scan ZAP sur $TARGET_URL..."

# Lancement du scan en mode headless
/opt/zap/zap.sh -cmd -quickurl $TARGET_URL -quickout /tmp/$REPORT_NAME

# Upload du rapport vers S3
aws s3 cp /tmp/$REPORT_NAME s3://$BUCKET_NAME/reports/$REPORT_NAME

echo "Scan terminé et rapport uploadé."
\end{lstlisting}

\subsection{4.3 Gestion des Permissions (IAM)}
L'instance EC2 possède un profil d'instance IAM (\texttt{SecurityInstanceProfile}) extrêmement restreint.

\begin{lstlisting}[language=json, caption=Politique IAM de l'Instance de Scan]
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": ["s3:PutObject"],
            "Resource": "arn:aws:s3:::can2025-security-reports/*"
        }
    ]
}
\end{lstlisting}
\textbf{Analyse} : Même si cette instance est compromise par un attaquant, il ne pourra rien faire d'autre que d'écrire des fichiers dans un bucket S3 spécifique. Il ne pourra pas lire les billets, ni accéder aux clés KMS.

\newpage

% ---------------------------------------------------------------------------
\section{5. Intégration SIEM avec Azure Sentinel}

La surveillance est le dernier rempart de la sécurité. Nous avons choisi \textbf{Microsoft Sentinel} pour ses capacités d'analyse avancée et d'IA, créant ainsi une architecture de sécurité hybride (AWS pour le compute, Azure pour le SIEM).

\subsection{5.1 Architecture d'Ingestion de Données}
Le défi principal était de faire communiquer AWS et Azure de manière fluide et sécurisée. Nous avons implémenté un pipeline d'ingestion personnalisé.

\begin{enumerate}
    \item \textbf{Source (AWS)} : Les fonctions Lambda écrivent leurs logs d'exécution et d'audit dans \textbf{CloudWatch Logs}.
    \item \textbf{Transporteur (Lambda Shipper)} : Une fonction Lambda dédiée (\texttt{sentinelShipper}) est abonnée aux Log Groups pertinents. Elle est déclenchée en temps réel à chaque nouveau lot de logs.
    \item \textbf{Transformation} : Le shipper décompresse les logs (Gzip), les parse en JSON structuré, et ajoute des métadonnées (Environnement, Source).
    \item \textbf{Ingestion (Azure)} : Les logs sont envoyés via HTTPS à l'API \textbf{Azure Monitor HTTP Data Collector}. L'authentification se fait via une signature HMAC-SHA256 utilisant la clé partagée du Workspace.
\end{enumerate}

\begin{figure}[H]
\centering
\begin{tikzpicture}[node distance=2cm, auto, >=stealth]
    \node[draw, rectangle] (cw) {CloudWatch Logs};
    \node[draw, rectangle, right of=cw, xshift=2cm] (lambda) {Lambda Shipper};
    \node[draw, rectangle, right of=lambda, xshift=2cm] (api) {Azure API};
    \node[draw, cylinder, shape border rotate=90, aspect=0.25, right of=api, xshift=1cm] (law) {Log Analytics};
    
    \draw[->] (cw) -- node[above] {Trigger} (lambda);
    \draw[->] (lambda) -- node[above] {HTTPS POST} (api);
    \draw[->] (api) -- (law);
\end{tikzpicture}
\caption{Pipeline d'ingestion AWS vers Azure}
\end{figure}

\subsection{5.2 Configuration de Microsoft Sentinel}
\subsubsection{Log Analytics Workspace}
Toutes les données sont stockées dans un Workspace dédié (\texttt{FanOps-Security-WS}).
\begin{itemize}
    \item \textbf{Rétention} : 90 jours (Conformité).
    \item \textbf{Tables Personnalisées} : Les logs applicatifs sont stockés dans la table \texttt{AppEvents\_CL}.
\end{itemize}

\subsection{5.3 Règles de Détection Avancées (KQL)}
Nous avons défini des règles analytiques pour détecter les comportements malveillants en temps réel.

\subsubsection{Règle 1 : Détection de Brute Force Distribué}
Cette règle détecte si une même IP échoue à se connecter plus de 10 fois en 5 minutes.
\begin{lstlisting}[language=SQL, caption=KQL - Brute Force]
AppEvents_CL
| where EventName_s == "Login_Failure"
| summarize FailureCount = count() by IPAddress_s, bin(TimeGenerated, 5m)
| where FailureCount > 10
| project TimeGenerated, IPAddress_s, FailureCount, Severity="High", Description="Brute Force Detected"
\end{lstlisting}

\subsubsection{Règle 2 : Détection de Fraude (Replay Attack)}
Cette règle est critique pour la billetterie. Elle alerte si un même portique rejette plusieurs billets pour cause de "Déjà utilisé" dans un court laps de temps, indiquant une tentative de fraude organisée.
\begin{lstlisting}[language=SQL, caption=KQL - Fraude Massive]
AppEvents_CL
| where EventName_s == "Replay_Attack"
| summarize AttackCount = count() by GateID_s, bin(TimeGenerated, 10m)
| where AttackCount > 5
| project TimeGenerated, GateID_s, AttackCount, Severity="Critical", Description="Possible Organized Fraud at Gate"
\end{lstlisting}

\subsubsection{Règle 3 : Anomalie de Géolocalisation (Impossible Travel)}
Grâce à l'enrichissement des logs par Sentinel, nous pouvons détecter si un agent se connecte depuis deux pays différents en moins d'une heure (Impossible Travel).
\begin{lstlisting}[language=SQL, caption=KQL - Impossible Travel]
let login_locations = AppEvents_CL 
| where EventName_s == "Login_Success"
| extend Country = geo_info_from_ip_address(IPAddress_s).country
| summarize Countries = make_set(Country) by UserId_s, bin(TimeGenerated, 1h);
login_locations
| where array_length(Countries) > 1
\end{lstlisting}

\newpage

% ---------------------------------------------------------------------------
\section{6. Cycle de Mise en Œuvre (DevSecOps)}

\subsection{6.1 Infrastructure as Code (IaC)}
L'utilisation du Framework Serverless nous permet de versionner notre infrastructure comme du code.

\begin{lstlisting}[language=yaml, caption=Configuration serverless.yml (Extrait)]
service: can2025-secure-gates
provider:
  name: aws
  runtime: nodejs20.x
  region: eu-west-1
  environment:
    USED_JTI_TABLE: ${self:service}-used-jti-${opt:stage}
    
functions:
  verifyTicket:
    handler: src/handlers/verifyTicket.handler
    events:
      - http:
          path: /security/verifyTicket
          method: post
          cors: true
\end{lstlisting}

\subsection{6.2 Déploiement Continu}
Le déploiement se fait en une seule commande :
\texttt{serverless deploy --stage dev}

Cette commande effectue les actions suivantes :
\begin{enumerate}
    \item Compilation du code TypeScript/JS.
    \item Création du template CloudFormation.
    \item Création du bucket S3 de déploiement.
    \item Upload des artefacts (Code zippé).
    \item Mise à jour de la stack CloudFormation (Création des tables, Lambdas, API Gateway).
\end{enumerate}

\newpage

% ---------------------------------------------------------------------------
\section{7. Analyse FinOps (Coûts)}

L'un des avantages majeurs de cette architecture est son coût extrêmement faible hors événement.

\subsection{7.1 Modèle de Coût}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|r|}
\hline
\textbf{Service} & \textbf{Unité de Facturation} & \textbf{Coût Unitaire} \\ \hline
AWS Lambda & Par 1M requêtes & \$0.20 \\ \hline
AWS Lambda & Par GB-seconde & \$0.0000166667 \\ \hline
DynamoDB & Par 1M écritures & \$1.25 \\ \hline
DynamoDB & Par 1M lectures & \$0.25 \\ \hline
API Gateway & Par 1M appels & \$3.50 \\ \hline
EC2 (t3.micro) & Par heure & \$0.0104 \\ \hline
Azure Sentinel & Par GB ingéré & \$2.30 \\ \hline
\end{tabular}
\caption{Grille Tarifaire (Région eu-west-1)}
\end{table}

\subsection{7.2 Estimation Mensuelle (Scénario Moyen)}
Pour un mois avec 4 matchs (env. 200 000 spectateurs au total) :

\begin{itemize}
    \item \textbf{Lambda} : 500k exécutions = \$0.10
    \item \textbf{API Gateway} : 500k appels = \$1.75
    \item \textbf{DynamoDB} : 1M opérations = \$1.50
    \item \textbf{EC2} : 720 heures = \$7.50
    \item \textbf{Sentinel} : 2 GB de logs = \$4.60
    \item \textbf{Total} : \textbf{\$15.45 / mois}
\end{itemize}

C'est un coût dérisoire comparé à une infrastructure classique (Load Balancer + Cluster de serveurs) qui coûterait au minimum \$100/mois même à vide.

\newpage

% ---------------------------------------------------------------------------
\section{8. Guide d'Utilisation et Démonstration}

\subsection{8.1 Scénario de Démonstration}
Pour valider le fonctionnement du système, nous suivons le protocole suivant :

\begin{enumerate}
    \item \textbf{Génération de Billets} : Exécution du script \texttt{seedTickets.js} pour créer 10 billets valides dans DynamoDB.
    \item \textbf{Connexion Agent} : L'agent se connecte sur le Frontend. Un JWT d'authentification est délivré.
    \item \textbf{Scan Valide} : L'agent scanne le billet \#1. Le système répond "Vert".
    \item \textbf{Tentative de Fraude (Replay)} : L'agent scanne le billet \#1 une seconde fois. Le système répond "Rouge" (Déjà utilisé).
    \item \textbf{Vérification SIEM} : Dans Azure Sentinel, nous observons l'apparition de l'alerte "Replay Attack" en moins de 2 minutes.
\end{enumerate}

\subsection{8.2 Gestion des Incidents}
Si une attaque est détectée (ex: DDoS ou Brute Force) :
\begin{itemize}
    \item L'alerte remonte dans Sentinel.
    \item Le SOC peut bloquer l'IP via le WAF (Web Application Firewall) d'AWS (évolution future).
    \item Les clés de signature peuvent être rotées immédiatement via la fonction \texttt{rotateKey}.
\end{itemize}

\newpage

% ---------------------------------------------------------------------------
\section{9. Conclusion et Perspectives}

Le module \textbf{M2 - Secure Gates} démontre qu'il est possible de concilier \textbf{haute sécurité}, \textbf{performance extrême} et \textbf{coûts réduits}.

\subsection{9.1 Bilan}
\begin{itemize}
    \item \textbf{Sécurité} : Architecture Zero Trust, Chiffrement de bout en bout, Audit continu.
    \item \textbf{Performance} : Temps de réponse moyen < 100ms.
    \item \textbf{Coût} : Modèle Pay-per-use très économique.
\end{itemize}

\subsection{9.2 Évolutions Futures}
Pour aller encore plus loin, nous envisageons :
\begin{itemize}
    \item \textbf{WAF AWS} : Ajouter une couche de protection contre les attaques applicatives (SQLi, XSS) directement sur l'API Gateway.
    \item \textbf{Offline Mode} : Permettre aux terminaux de scanner les billets même en cas de coupure réseau (synchronisation différée), bien que cela pose des défis pour l'anti-replay.
    \item \textbf{IA Prédictive} : Utiliser Azure Sentinel pour prédire les pics d'affluence aux portes.
\end{itemize}

Ce projet constitue une brique fondatrice solide pour l'infrastructure IT de la CAN 2025.

\end{document}
